'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _process = require('process');

var _process2 = _interopRequireDefault(_process);

var _fsExtra = require('fs-extra');

var _generateJson = require('./generateJson');

var _multipleCucumberHtmlReporter = require('multiple-cucumber-html-reporter');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FEATURE = 'Feature';
var SCENARIO = 'Scenario';
var NOT_KNOWN = 'not known';
var AFTER = 'After';
var BEFORE = 'Before';
var TEXT_PLAIN = 'text/plain';

var MultipleCucumberHtmlReporter = function (_events$EventEmitter) {
    _inherits(MultipleCucumberHtmlReporter, _events$EventEmitter);

    function MultipleCucumberHtmlReporter(baseReporter, config) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        _classCallCheck(this, MultipleCucumberHtmlReporter);

        var _this = _possibleConstructorReturn(this, (MultipleCucumberHtmlReporter.__proto__ || Object.getPrototypeOf(MultipleCucumberHtmlReporter)).call(this));

        if (!options.htmlReporter) {
            throw new Error('Options need to be provided.');
        }

        if (!options.htmlReporter.jsonFolder) {
            throw new Error('A path which holds the JSON files should be provided.');
        }

        if (!options.htmlReporter.reportFolder) {
            throw new Error('An output path for the reports should be defined, no path was provided.');
        }

        _this.options = options.htmlReporter;
        // this.baseReporter = baseReporter;
        _this.instanceData = {};
        _this.results = {};
        _this.scenarioName = null;

        // this.on('hook:start', ::this.hookStart);
        // this.on('hook:end', ::this.hookEnd);

        _this.on('start', _this.onStart.bind(_this));

        // Test framework events
        _this.on('suite:start', _this.suiteStart.bind(_this));
        // this.on('suite:end', ::this.suiteEnd);
        _this.on('test:start', _this.testStart.bind(_this));
        _this.on('test:pass', _this.testPass.bind(_this));
        _this.on('test:fail', _this.testFail.bind(_this));
        _this.on('test:pending', _this.testPending.bind(_this));

        // Runner events (webdriver)
        // this.on('start', ::this.start);
        // this.on('runner:command', ::this.runnerCommand);
        _this.on('runner:result', _this.runnerResult.bind(_this));
        _this.on('end', _this.onEnd.bind(_this));

        // Multiple Cucumber HTML events
        _this.on('mchr:attachment', _this.mchrAttachment.bind(_this));
        return _this;
    }

    _createClass(MultipleCucumberHtmlReporter, [{
        key: 'onStart',
        value: function onStart() {
            if (this.options.removeFolders) {
                (0, _fsExtra.removeSync)(this.options.jsonFolder);
                (0, _fsExtra.removeSync)(this.options.reportFolder);
            }
        }

        // hookStart(payload) {}
        // hookEnd(payload) {}

    }, {
        key: 'suiteStart',
        value: function suiteStart(suite) {
            var cid = suite.cid;
            if (!this.results[cid]) {
                this.results[cid] = this.getFeatureDataObject(suite);
            }
            this.scenarioName = suite.title;
        }

        // suiteEnd(suite) {}

    }, {
        key: 'testStart',
        value: function testStart(test) {
            if (!this.results[test.cid]._elements[test.parent]) {
                this.results[test.cid]._elements[test.parent] = this.getScenarioDataObject(test);
            }
        }
    }, {
        key: 'testPass',
        value: function testPass(test) {
            this.results[test.cid]._elements[test.parent].steps.push(this.getStepDataObject(test, 'passed'));
        }
    }, {
        key: 'testFail',
        value: function testFail(test) {
            this.results[test.cid]._elements[test.parent].steps.push(this.getStepDataObject(test, 'failed'));
        }
    }, {
        key: 'testPending',
        value: function testPending(test) {
            this.results[test.cid]._elements[test.parent].steps.push(this.getStepDataObject(test, 'pending'));
        }

        /**
         * Runner
         */
        // runnerCommand(command) {}

    }, {
        key: 'runnerResult',
        value: function runnerResult(result) {
            // Save browserdata so it can be used later
            var cid = result.cid;
            if (!this.instanceData[cid]) {
                this.instanceData[cid] = this.determineMetadata(result);
            }
        }
    }, {
        key: 'onEnd',
        value: function onEnd(payload) {
            var jsonFolder = this.options.jsonFolder;

            // Generate the jsons
            (0, _generateJson.generateJson)(jsonFolder, this.results);

            // generate the report
            (0, _multipleCucumberHtmlReporter.generate)(_extends({
                // Required
                jsonDir: jsonFolder,
                reportPath: this.options.reportFolder
            }, this.options.customData ? { customData: this.options.customData } : {}, this.options.customStyle ? { customStyle: this.options.customStyle } : {}, {
                disableLog: this.options.disableLog || false,
                displayDuration: this.options.displayDuration || false,
                durationInMS: this.options.durationInMS || false,
                openReportInBrowser: this.options.openReportInBrowser || false
            }, this.options.overrideStyle ? { overrideStyle: this.options.overrideStyle } : {}, this.options.pageFooter ? { pageFooter: this.options.pageFooter } : {}, this.options.pageTitle ? { pageTitle: this.options.pageTitle } : {}, this.options.reportName ? { reportName: this.options.reportName } : {}, {
                saveCollectedJSON: this.options.saveCollectedJSON || false
            }));
        }

        /**
         * All functions
         */

        /**
         * Get the feature data object
         *
         * @param {object} featureData
         *
         * @returns {
         *  {
         *      keyword: string,
         *      line: number,
         *      name: string,
         *      tags: string,
         *      uri: string,
         *      _elements: {object},
         *      elements: Array,
         *      id: string,
         *      _attachment: Array
         *  }
         * }
         */

    }, {
        key: 'getFeatureDataObject',
        value: function getFeatureDataObject(featureData) {
            return _extends({
                keyword: FEATURE,
                description: this.escapeHTML(featureData.description),
                line: parseInt(featureData.uid.substring(featureData.title.length, featureData.uid.length)),
                name: this.escapeHTML(featureData.title),
                tags: featureData.tags,
                uri: featureData.specs[0],
                _elements: {}, // Temporary. All data will be copied to the `elements` when done
                elements: [],
                id: featureData.title.replace(/ /g, '-').toLowerCase(),
                _attachment: [] }, this.instanceData[featureData.cid]);
        }

        /**
         * Get the scenario data object
         *
         * @param {object} scenarioData This is the testdata of the current scenario
         *
         * @returns {
         *  {
         *      keyword: string,
         *      line: number,
         *      name: string,
         *      tags: string,
         *      id: string,
         *      steps: Array
         *  }
         * }
         */

    }, {
        key: 'getScenarioDataObject',
        value: function getScenarioDataObject(scenarioData) {
            return {
                keyword: SCENARIO,
                description: this.escapeHTML(scenarioData.description),
                line: parseInt(scenarioData.parent.substring(this.scenarioName.length, scenarioData.parent.length)),
                name: this.escapeHTML(this.scenarioName),
                tags: scenarioData.tags,
                id: this.results[scenarioData.cid].id + ';' + this.scenarioName.replace(/ /g, '-').toLowerCase(),
                steps: []
            };
        }

        /**
         * Get the step data object
         *
         * @param {object} stepData This is the testdata of the step
         * @param status
         * @returns {{arguments: Array, keyword: string, name: *, result: {status: *, duration: *}, line: number, match: {location: string}}}
         */

    }, {
        key: 'getStepDataObject',
        value: function getStepDataObject(stepData, status) {
            var stepResult = _extends({
                arguments: stepData.argument || [],
                // keyword: ' ',
                keyword: stepData.keyword || ' ',
                name: this.escapeHTML(stepData.title),
                result: _extends({
                    status: status,
                    duration: stepData.duration * 1000000
                }, this.addFailedMessage(stepData, status)),
                line: parseInt(stepData.uid.substring(stepData.title.length, stepData.uid.length))
            }, this.defineEmbeddings(stepData.cid), {
                match: {
                    location: 'can not be determined with webdriver.io'
                }
            });

            return stepResult;
        }

        /**
         * Define the embeddings
         *
         * @param {string} cid The current instance id
         *
         * @returns {{
         *      embeddings: *
         *  } || {}
         * }
         */

    }, {
        key: 'defineEmbeddings',
        value: function defineEmbeddings(cid) {
            var embeddings = this.results[cid]._attachment.length > 0 ? { embeddings: [].concat(_toConsumableArray(this.results[cid]._attachment)) } : {};

            // Empty the attachments because there is no data anymore, step has finished
            this.results[cid]._attachment = [];

            return embeddings;
        }

        /**
         * Add a failed message
         *
         * @param {object}  testObject
         * @param {string}  status
         *
         * @return {object}
         */

    }, {
        key: 'addFailedMessage',
        value: function addFailedMessage(testObject, status) {
            if (status === 'failed') {
                return {
                    error_message: testObject.err.stack
                };
            }

            return {};
        }

        /**
         * Determine the metadata that needs to be added
         *
         * @TODO: Need to look at the implementation, is not that nice
         *
         * @param {object} data instance data
         *
         * @returns {
         *  {
         *      metadata: {
         *          app: {
         *              name: string,
         *              version: string
         *          },
         *          browser: {
         *              name: string,
         *              version: string
         *          },
         *          device: string,
         *          platform: {
         *              name: string,
         *              version: string
         *          }
         *      }
         *  }
         * }
         */

    }, {
        key: 'determineMetadata',
        value: function determineMetadata(data) {
            var app = void 0,
                browser = void 0;
            var desiredCapabilities = data.requestData.desiredCapabilities;
            var metadata = desiredCapabilities.metadata || {};
            var bodyValue = data.body.value || {};

            // When an app is used to test
            if (bodyValue.app || bodyValue.testobject_app_id || metadata.app) {
                var metaAppName = metadata.app && metadata.app.name ? metadata.app.name : 'No metadata.app.name available';
                var metaAppVersion = metadata.app && metadata.app.version ? metadata.app.version : 'No metadata.app.version available';
                var appPath = bodyValue.app || bodyValue.testobject_app_id || metaAppName;
                var appName = appPath.substring(appPath.replace('\\', '/').lastIndexOf('/')).replace('/', '');

                // Provide the app name and version
                app = {
                    app: {
                        name: appName,
                        version: metaAppVersion
                    }
                };
                // Provide the devicename if there
                metadata.device = desiredCapabilities.deviceName || bodyValue.deviceName || metadata.device || null;
                metadata.platform = {
                    name: desiredCapabilities.platformName || bodyValue.platformName || metadata.platform && metadata.platform.name || 'No metadata.platform.name available',
                    version: desiredCapabilities.platformVersion || bodyValue.platformVersion || metadata.platform && metadata.platform.version || 'No metadata.platform.version available'
                };
            } else {
                var browserName = bodyValue.browserName || (metadata && metadata.browser && metadata.browser.name ? metadata.browser.name : 'No metadata.browser.name available');
                var browserVersion = bodyValue.version || bodyValue.browserVersion || (metadata && metadata.browser && metadata.browser.version ? metadata.browser.version : 'No metadata.browser.version available');

                browser = {
                    browser: {
                        name: browserName,
                        version: browserVersion
                    }
                };
            }

            var device = metadata && metadata.device ? metadata.device : NOT_KNOWN;
            var platform = {
                name: metadata && metadata.platform && metadata.platform.name ? metadata.platform.name : NOT_KNOWN,
                version: metadata && metadata.platform && metadata.platform.version ? metadata.platform.version : NOT_KNOWN
            };

            return {
                metadata: _extends({}, app || browser, {
                    device: device,
                    platform: platform
                })
            };
        }

        /**
         * Escape html in strings
         *
         * @param   {string}  string
         * @return  {string}
         */

    }, {
        key: 'escapeHTML',
        value: function escapeHTML(string) {
            return !string ? string : string.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/\'/g, '&#39;');
        }

        /**
         * Attach data to the report
         *
         * @param {string|object} data
         * @param {string} type Default is `text/plain`, otherwise what people deliver as a MIME type, like `application/json`, `image/png`
         * @param {string|undefined} hookType This will tell if the attach needs to take place for a before or after hook
         */

    }, {
        key: 'mchrAttachment',


        /**
         * Add the attachment to the result
         *
         * @param {string} cid
         * @param {string|object} data
         * @param {string} type
         * @param {string|undefined} hookType This will tell if the attach needs to take place for a before or after hook
         */
        value: function mchrAttachment(_ref) {
            var cid = _ref.cid,
                data = _ref.data,
                type = _ref.type,
                hookType = _ref.hookType;

            var hook = void 0;
            // It could be that people don't provide the type, but just the hookType, so check that here
            type = this.validateHookType(type);
            if (type === BEFORE || type === AFTER) {
                hook = type;
                // Set the type to the default if the type has been used to set the hookType
                type = TEXT_PLAIN;
            }

            if (hookType) {
                hook = this.validateHookType(hookType);
            }

            if (data.value) {
                data = data.value;
            } else if (data.data) {
                data = Buffer.from(data.data).toString('base64');
            }

            // This will push all data that has been attached to the global, this will be parsed and cleaned for
            // each executed step (test) in the `passed||failed||pending`-state
            this.results[cid]._attachment.push({
                data: data,
                mime_type: type
            });

            // If a hook  is used, add the hook data
            if (hook) {
                this.addHookData(cid, hook);
            }
        }

        /**
         * Validate if the hook type that is used is a valid hook or not
         *
         * @param {string} string
         *
         * @return {string}
         */

    }, {
        key: 'validateHookType',
        value: function validateHookType(string) {
            if (string && (this.capitalizeFirstLetter(string) === AFTER || this.capitalizeFirstLetter(string) === BEFORE)) {
                return this.capitalizeFirstLetter(string) === AFTER ? 'After' : 'Before';
            }

            return string;
        }

        /**
         * Capitalize the first letter of the string
         *
         * @param {string} string
         *
         * @return {string}
         */

    }, {
        key: 'capitalizeFirstLetter',
        value: function capitalizeFirstLetter(string) {
            return string.charAt(0).toUpperCase() + string.toLowerCase().slice(1);
        }

        /**
         * Determine the hook data and determine if a before or after hook step needs to be made
         *
         * @param {number} cid
         * @param {string} hookType
         */

    }, {
        key: 'addHookData',
        value: function addHookData(cid, hookType) {
            var scenarios = this.results[cid]._elements;
            var currentScenario = Object.keys(scenarios)[Object.keys(scenarios).length - 1];
            var hookStepData = {
                keyword: hookType,
                title: '',
                uid: '',
                duration: 0,
                cid: cid
            };
            var stepsArray = scenarios[currentScenario].steps;

            if (hookType === AFTER) {
                this.addAfterHookData(cid, currentScenario, hookStepData, stepsArray);
            } else {
                this.addBeforeHookData(cid, currentScenario, hookStepData, stepsArray);
            }
        }

        /**
         * Add after hook data, also determine if there is already an after hook, if so, add it to the current one
         *
         * @param {number} cid
         * @param {string} currentScenario
         * @param {string} hookStepData
         * @param {object} stepsArray
         */

    }, {
        key: 'addAfterHookData',
        value: function addAfterHookData(cid, currentScenario, hookStepData, stepsArray) {
            if (stepsArray[stepsArray.length - 1].keyword === AFTER) {
                stepsArray[stepsArray.length - 1].embeddings.push(this.results[cid]._attachment[0]);
                this.results[cid]._attachment = [];
            } else {
                var hookData = this.getStepDataObject(hookStepData, 'passed');
                this.results[cid]._elements[currentScenario].steps.push(hookData);
            }
        }

        /**
         * Add before hook data, also determine if there is already a before hook, if so, add it to the current one
         *
         * @param {number} cid
         * @param {string} currentScenario
         * @param {string} hookStepData
         * @param {object} stepsArray
         */

    }, {
        key: 'addBeforeHookData',
        value: function addBeforeHookData(cid, currentScenario, hookStepData, stepsArray) {
            if (stepsArray[0] && stepsArray[0].keyword === BEFORE) {
                stepsArray[stepsArray.length - 1].embeddings.push(this.results[cid]._attachment[0]);
                this.results[cid]._attachment = [];
            } else {
                var hookData = this.getStepDataObject(hookStepData, 'passed');
                this.results[cid]._elements[currentScenario].steps.unshift(hookData);
            }
        }
    }], [{
        key: 'attach',
        value: function attach(data) {
            var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TEXT_PLAIN;
            var hookType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

            _process2.default.send(_extends({ event: 'mchr:attachment' }, { data: data, type: type, hookType: hookType }));
        }
    }]);

    return MultipleCucumberHtmlReporter;
}(_events2.default.EventEmitter);

MultipleCucumberHtmlReporter.reporterName = 'multiple-cucumber-html-reporter';
exports.default = MultipleCucumberHtmlReporter;
module.exports = exports['default'];